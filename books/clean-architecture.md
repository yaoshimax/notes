## クリーンアーキテクチャを読んでメモ
### 第一部
#### 1章

- アーキテクチャの目的はシステムの構築・保守に必要な人材を最小限に抑えること

#### 2章

- システムは「構造」と「振る舞い」からなるという。
  - 振る舞いは機能要件。構造はアーキテクチャ。前者が重視されがち
- ソフトウェアはソフトである…つまり、変更を簡単にできるべきものである。この点で構造は重要である。
- 緊急と重要は違う。振る舞いは緊急、アーキテクチャは重要。緊急かつ重要であるとは限らない。
  - 緊急と重要はどうちがう？があまり明文化されてないので若干ポエミーさを感じた。わからなくもないきはするなんとなく。

### 第二部

アーキテクチャの議論をする前の下地づくりとしての説明っぽさ

#### 3章:パラダイム

- 構造化プログラミング：gotoやめようby dijkstra。直接的な制御の移行に規律を課す
- オブジェクト指向プログラミング：クラスとかポリモーフィズムとか。間接的な制御の移行に規律を課す
- 関数型プログラミング：シンボルの値は変化しない。代入に規律を課す

どれもプログラマの行動を制限している。これらはどれもアーキクチャの３つの関心事と対応している

#### 4章: 構造化プログラミング

- パンチカードとかの時代。djkstraのモチベーションは数学の考え方を使ってプログラムを書くことっぽい
- gotoがあると分割統治とかの証明ができない->gotoいらない証明をした
- 構造化プログラミングでは、モジュールを機能的に分割できる。分割したものがテストで反証可能となれば構造化プログラミングのメリットになる。
  - テストは「正しくない」ことの証明を試みるもの。プログラムが正しい証明にはならないが。反証を試みて無理だった＝十分正しいだろう、という考え

#### 5章: オブジェクト指向プログラミング

- OOはポリモーフィズムの能力でソースコードの依存関係を絶対的に制御できる＝上位モジュールと下位モジュールの分離
  - カプセル化：C言語でも実はカプセル化できる。OO言語は逆にカプセル化が弱体化してる（ヘッダファイル上でメソッド変数が見える
  - 継承: 一応C言語でもできる。でも多重継承とかはめんどい。OO言語の方が楽
  - ポリモーフィズム: Cでも関数ポインタの付け替えでできる。でも関数ポインタを使うのは危険→ポインタ経由で関数を呼び出す、という規約をなくしてポリモーフィズムしやすくしたのがOO言語
    - ポリモーフィズムがあるとIOデバイスが変わってもopen/close/read/write/seekが実装されてれば呼び出し側は変更不要。この切り分けが便利
    - HLがInterfaceを実装したMLの関数を呼ぶ、みたいな構造は `HL→Interface<|- ML`とかける。 制御の流れ(HL->ML)に対し依存・継承関係が逆転する。
       - 制御の流れと無関係に依存ができる（依存の絶対制御）＝制御される側も制御する側を切り分けられる
       - UI/ビジネスルール/DBそれぞれが独立したものにできる。独立開発・独立デプロイ可能

#### 6章: 関数型プログラミング

- 関数型言語の変数は変化しない（不変性）
- 競合・デッドロック・並行更新の問題の原因は可変変数。よって不変性は並列計算で便利
- 不変性はつかえるのか？＝妥協すれば使える
  - 不変コンポーネントにできる限り処理を押し込みつつ無理な部分は可変コンポーネント＋トランザクショナルメモリをつかって良いとする
  - 無限にリソースがあるならトランザクションを保存して必要なときにデータを作るのが完全な関数型。でもストレージが死ぬのでよしなに
    - 銀行口座の例では、金額を覚えないのが改善な関数型だが、0時には値を計算してその差分だけ計算、とか。

若干結論が見えづらく感じたが、三章にもあるように、不変性により代入に規律を課したがポイントであろう

### 第三部：設計の原則

思考の拠り所としてSOLID原則を説明する。この原則に従えば

- 変更に強い
- 理解しやすい
- コンポーネントの基盤として多くのシステムで利用できる

システムがつくれる。

#### 7章：SOLIDのS: Single Responcibility Principle(SRP)

- 単一責任の原則というが、「どのモジュールも一つのことだけやるべき」ではない。
- モジュールは、たった一つのアクター（ソフトウェアを変更したいと思う人）に対して責務を追うべき
  - Aが使う関数FをAの要求変更に合わせて変更したらBもFを使っていてトラブった、をやめたい
- データを持つクラスと処理するクラスを分ける＆処理するクラスをまとめるためにFacadeパターンがつかえる

#### 8章: SOLIDのO: Open-Closed Principle(OCP)

- ソフトウェアは拡張に対して開いていて修正に対しては閉じているべき
- 既存の成果物を変更せず拡張できるようにしたい
- 変更の理由が異なるものを分割。依存関係を依存関係逆転の原則（後にでてきそう。順序逆転や情報保護にInterfaceが使えるっぽさはある）でまとめる
 - 依存順：AがBの変更から保護されるべきなら、BからAに依存すべき。


#### 9章: SOLIDのL: リスコフの置換原則

- S型オブジェクトo1各々に対応するT型オブジェクトo2があり、Tを使って定義されたプログラムPにo2の代わりにo1を適用してもPの振る舞いが変わらないならば、SはTの派生型
  - PersonalLicenseとBusinecceLicenseはcalcFee関数を持つLicenseの派生型
  - 正方形は長方形の派生クラスではない。幅を変える・高さを変える・面積を計算するを利用するプログラムを書くとおかしなことになる
- 昔は継承の使い方指針だったが、今はインターフェースと実装の原則にまで広がってる
  - 違反の例: タクシー配車サービス。色んな会社の配車サービスが特定REST APIに対応してる前提で配車リクエストを投げる処理を書く→例外サイトが出ると大変。URIをキーにコマンド作成モジュールを作る必要がでる
  - 予めコマンド作成モジュールを作っておくべきという話ではなく、置換できない例外的モジュールはつくらないようにしようね…という主張なのかなぁ…？

#### 10章: SOLIDのI: インターフェース分離の原則(ISP)

- User1がOP1, User2がOP2, User3がOP3を使うようなクラスOPSがある。これだけだとUser1は暗黙的にOP2に依存する -> OP{1..3}を持つInterface{1..3}を使って実装させよう
- アーキテクト的にも似たようなことが言える。フレームワークFを使おうとしたら暗黙的にデータベースDに依存するようになった（つかわないのに）とかは避けたいね、という話

#### 11章: SOLIDのD: 依存関係逆転の原則(DIP)

- ソースコードの依存関係が抽象だけを参照している＝柔軟
- ガチガチに抽象化する必要はない。stringを抽象化しないでよい。
- ただ、システム内の変化しやすい具象要素には依存しないようにすべき。安定した抽象要素を使おう
  - 変化しやすい具象クラスを参照しない・継承しない・オーバーライドしない
- Abstract Factoryパターンが使える
  - ApplicationはServiceFactory(Interface)のmakeSvcでService(Interface)を作ってServiceの各操作を呼ぶ。処理内容はそれぞれの実装クラスの中でやる。

### 第四部: コンポーネントの原則

SOLIDより一段上の粒度。ソフトウェアをコンポーネントに分ける周りの話をする

#### 12章: コンポーネント

- コンポーネントとは、デプロイの単位のこと
- プログラムの置き場所の変遷
  - メモリの番地を手で書く。ライブラリもソースコードそのまま貼り付け
  - 固定の関数ライブラリとアプリケーション領域→アプリケーション肥大化で収まりきらなくなる
  - 再配置可能なバイナリとリンクローダ
  - リンクとロードの処理を切り分ける。リンカの誕生
- プログラムも肥大化よりリンクの時間も短縮効果がきいてきて、コンポーネントをプラグイン化するアーキテクチャも生まれてきた。

#### 13章: コンポーネントの凝縮性

- どのクラスをどのコンポーネントに入れる？の原則は3つある
  - 再利用・リリース等価の原則：再利用の単位とリリースの単位は等価になる
    - コンポーネントには一貫するテーマ・目的があり、それを共有するモジュールを集める
    - コンポーネントを形成するクラス・モジュールはまとめてリリース可能
    - この原則がかけると再利用性が低下する
  - 閉鎖性共通の原則：変更の理由やタイミングの同じクラスは同一コンポーネントに、異なるクラスは別コンポーネントにする
    - 単一責任の原則のコンポーネント版
    - オープン・クローズドの原則の「修正に対して閉じる」を噛み砕いたものとも言える
    - この原則がかけると変更コンポーネントが増える
  - 全再利用の原則：コンポーネントユーザに実際に使わないものの依存を強要しない
    - インターフェース分離の原則の一般化
    - 不要なものには依存しない
    - この原則がかけると不要なリリース作業が増える
- 前２つはコンポーネントを大きくするが全再利用の原則はコンポーネントを小さくする、相反する概念
  - アーキテクトは現在の状況に合わせてバランスを取るのが大事
  - フェーズによって重視するものも変わる。開発初期は再利用・リリース等価より閉鎖性共通のほうが大事

#### 14章: コンポーネントの結合

- 非循環依存関係の原則: コンポーネントは循環依存してはいけない
  - 他の人の変更が悪さをして手元でプログラムが動かなる問題に対応するための原則
    - 週次ビルド（月-木は他の人の変更を無視し、金曜は統合作業を頑張る）というてもあるが、金曜が辛くなりがちだし木・土曜にずれ込みがち
  - コンポーネントごとに分割・依存コンポーネントがリリースされたときの導入は各コンポーネントが良きタイミングで行う…という流れを機能させるには、循環依存があってはいけない。
- 循環依存を解消するには？
  - 依存関係逆転の原則を使う。`E->A`の依存がある所は、EにInterfaceを作ってAに実装させれば`A<|-E`という依存になる
  - 共通のコンポーネントCを切り出して`E->A`という依存を `E->C<-A`という依存に変える
- 依存構造は変化していくので、コンポーネント構造をトップダウンで設計は不可能
  - 状況に応じてこれまでの原則を使いつつ、コンポーネントの依存構造をシステムの論理設計に合わせて育てていくもの
- 安定依存の原則：安定度の高い方向に依存すること
  - 変動を想定したコンポーネントは変動しづらいコンポーネントから依存されてはいけない。
  - 安全度とは、簡単に手を加えることができないこと。依存もとが多いと安定。依存先が多いと不安定。
  - 依存元/(依存先＋依存元) を不安定度の指標にする
    - 依存先・依存元の数は、コンポーネントごとの依存数より内部のクラスごとの依存を見るべし（importの数）
  - コンポーネント依存を順番にたどると不安定の度合いが減少する方向だと良い
- 安定度、抽象度等価の原則：コンポーネントの抽象度は安定度と同程度であるべき
  - 上位レベルの方針は頻繁に変わってほしくないので安定コンポーネントに配置すべきだが、拡張はできるようにしておきたい→インターフェースと抽象クラスで構成すべき
  - この原則に従えば、依存をたどっていくと順に抽象度は上がる
  - 抽象度は (抽象クラスやインターフェースの数)/全クラスの数 を指標にすると良い
  - 不安定度・抽象度を２次元にマッピングしてかんがえる。(0,1)が安定かつ抽象。(1,0)が不安定かつ具象。
    - (0,0) は安定な具象コンポーネント。抽象度が低いため拡張できず、安定度が高いから変更できない。変更することがほぼないなら害はないが、変更するなら苦痛ゾーン
    - (1,1) は不安定な抽象コンポーネント。実装がないのに放置されてる抽象クラスなど。無駄。
    - (0,1)-(1,0)の線分（主系列）にコンポーネントを極力近づけたい。主系列からの距離は|不安定度+抽象度-1|で表せる
      - コンポーネントごとに主系列の距離を計算して、値の大きいものを再検討すると良い。
      - 全体の平均・分散したり、時系列の推移を分析すると良い。

### 第五部: アーキテクチャ

- アーキテクチャの目的は、開発・デプロイ・運用・保守を容易にすること。そのためには、長い期間多くの選択肢を残す戦略が重要。
  - システムを適切に動作させることは主たる目的ではない。
- 残すべき選択肢とは、重要でない詳細である。
  - ソフトウェアは「方針」と「詳細」の要素に分割できる
  - 詳細は方針の実現に必要だが、方針の振る舞いに影響を与えない。
- 優れたアーキテクトは方針と詳細を区別し、方針が詳細を把握することなく、依存することがないように両者を切り離す。また、詳細をできるだけ延期・留保できるように方針をデザインする。
- 具体的なエピソード例
  - 初期段階でDBを接続する必要はない。誰かが決めていたとしてもアーキテクトとしては「決まっていない」という
  - IOデバイスを抽象化すること利用側はデバイスを意識しないで済む
  - ディスクの詳細構造（シリンダ・ヘッダ・セクタ）を知った上でアクセスするプログラムを書くのではなく、巨大配列の要素にアクセスするようにする

#### 16章: 独立性

- アーキテクチャは、システムのユースケース・運用・開発・デプロイをサポートしなければいけない
  - ユースケースをサポート
    - システムの意図をサポートする
    - アーキテクチャレベルでシステムの意図がわかると良い。詳細は21章
  - 運用をサポート
    - アクセスレベルなど、負荷に耐えれる必要がある
    - 小さいサービスに分けるかモノリシックか。優れたアーキテクトはこれらの決定を選択肢として残しておく
  - 開発をサポート
    - コンウェイの法則：システムを設計する組織は、組織のコミュニケーション構造をコピーした構造の設計を生み出す
    - チームの行動を独立させるために、単独で開発可能なコンポーネントにシステムを分割
  - デプロイをサポート
    - 目指せ即時デプロイ
    - これもシステムの適切なコンポーネント化で実現
- これらのバランスを取るのは難しい。すべてのユースケース、運用上の成約、チーム構造、デプロイ要件がわからなかったり、変化したりする。
  - このために選択肢を残すことが重要
- レイヤーによる切り離し
  - ユースケース全部はわからずとも、基本的な意図はわかる。ここから単一責任・閉鎖性共通の原則でコンポーネントを分けられる
  - UI・アプリケーション特有ビジネスルール・一般的（ドメイン特価）ビジネスルール・データベースなど。水平レイヤの分割。
- ユースケースによる切り離し
  - 注文新規追加のほうが注文キャンセルより変更頻度が多い
  - ユースケースは、システムの水平レイヤを垂直にスライスしたもの
  - UI/ビジネスルール/DBそれぞれユースケースごとに分離してグループ化->古いユースケースに影響を出さずに追加できる
- ユースケースの切り離しができてると運用・開発・デプロイの観点でも嬉しい
  - 高頻度で使われるユースケースだけ異なるサーバをつかうとかできる（運用）
  - 明確に切り離されてればチーム同士の干渉は避けられる（開発）
  - 独立にデプロイできる（デプロイ）
- 重複した処理をまとめる、の罠
  - 画面構成が同じ２つの異なるユースケースはコードを共有するべきではない
    - ユースケースが異なるならば、ときが経つに連れ少しずつ違ったものになる可能性が高いから
  - レイヤ分離も、画面のデータ構造がデータベースのレコードのデータ構造そのままだったりしても、直接参照せずビューモデルをつくるべし。
- 切り離しレベル
  - ソースレベル：ソースコードモジュール間の依存性管理(Ruby Gems)。コンポーネントはすべて同じアドレス空間で動く単一実行ファイルがある。モノリシック構造。
  - デプロイレベル：デプロイ可能な単位で依存性を管理する(jar)。多くは同じアドレス空間に存在。別なこともある。
  - サービスレベル：実行単位が完全に独立。ネットワークパケットのみで通信
  - PJ初期段階でどのレベルが最適なのかの判断は難しい。
    - これに対し最初からサービスレベルで切り離すという一つの手はあるが、問題もある。
      - 粗い切り離しになりがち
      - 開発時間とシステムリソースが高い
        -  必要とされないサービス境界を扱う労力がかかる
    - 筆者の推しは、いざというときにサービスを作れそうにしつつ、コンポーネントは同一アドレス空間に存在させておく
- 総括：切り離し、一筋縄ではいかない。
  - 切り離し方式は時間とともに変化する。これを予見して適切に進めるべし

#### 17章: 境界線を引く
- ユースケースと関係ない決定(早すぎる決定)との結合はマンパワーを奪う
  - フレームワーク、DB、ウェブサーバ、ユーティリティ、DIに関する決定
  - 優れたアーキテクチャはこれら決定を最終時点まで引き伸ばせる
  - 悪例：デスクトップアプリケーションを作ってた社がウェブ版を作ろうとした。３層構造アーキを採用し、GUI/ミドル/DB層にわかれ層間通信をさせた。しかし、これらの層が別サーバで可動することはなく、1台サーバ上で動かし続けた。新機能を実装する際にメッセージシリアライズ等の余計な開発工数は残った
    - アーキテクトが早すぎる決断を下すと開発労力が増えた
  - 好例：FIT(Framework for Integration Tests)のWikiラッパを作る際に…
    - 独自ウェブサーバを作った: ウェブフレームワークの決定を先延ばし
    - DBの決定を遅らせるため、データアクセスとデータリポジトリの間にインターフェイスを置く
      - 最終的にはDB使わずにファイル書き出しだけで済んだ
- 境界線ってどうやって引くか？
  - 重要なものと重要でないものの間に引く
    - GUIはビジネスルールにとって重要ではない
    - データベースはビジネスルールにとって重要ではない
      - よく密接に関係すると誤解されがちだが、ビジネスルール的にはデータを取得・保存する機能がある、ということだけわかればOK
  - GUI・データベースをビジネスルールのプラグインのような存在
  - 境界線を挟んだコンポーネントは、それぞれの変更頻度・理由が異なる。単一責任の原則も境界を引くのに役立つ

#### 18章: 境界の解剖学
境界にはいくつかの形がある
- モノリスとデプロイコンポーネント
  - ソースレベルの切り離し（モノリス）の場合
    - 下位から上位のサービスに対して関数呼び出しをする
  - デプロイレベルの切り離し（デプロイコンポーネント）の場合
    - 動的リンクライブラリ：境界の単純な物理的表現
      - 通信は結局関数呼び出しなので、モノリスとたいして変わらない
- より上位の境界
  - ローカルプロセス：強力な物理的境界。
    - プロセス間はソケットかメッセージキューなどを使ってやりとり
  - サービス：最も強力な境
    - サービス＝コマンドライン等で開始されるプロセス、物理的な場所に依存しない
    - 境界を超えるのに時間がかかる。これを覗いてはローカルプロセスと同じ。
      - 下位レベルのサービスは上位サービスのプラグインであるべき
      - 上位レベルのサービスでは下位サービスの物理的情報を含めては行けない
  - サービスやローカルプロセスの内部構造＝モノリスor動的にリンクされたデプロイコンポーネント

#### 19章: 方針とレベル
- 繰り返しになるが、良いアーキテクチャは下位が上位に依存するように設計する
- レベル＝入力と出力からの距離。
  - レベルが高い＝上位
- 処理の順番と依存の向きは等価ではない
  - 入力→変換→出力というフローがあれば変換が最も高レベル。依存の向きは入力→変換←出力

#### 20章: ビジネスルール
- ビジネスルールとはいったい？
  - 極論、金を生んだり節約したりするルール（ローンとか。最重要ビジネスルール）
  - 最重要ビジネスルールのために必要なデータ（ローンの場合の金利や貸付残高など）を最重要ビジネスデータと呼ぶ
- エンティティ
  - 最重要ビジネスデータを操作する最重要ビジネスルールをいくつか含んだオブジェクトのこと
    - ローン・顧客など
  - データベース・ユーザインターフェース・フレームワークからは切り離し、独立したものとすべし
- ユースケース
  - 自動化されたシステムを利用する方法のこと（ローン作成アプリで、連絡情報を入力とし、値を検証し、与信スコアが基準を超えてないと見積もり画面に進まない…みたいなはなし）
  - すなわち、アプリケーション固有のビジネスルール
  - エンティティの最重要ビジネスルールをどのように呼び出すかを規定している。
  - (重要)ユーザインターフェースについて記述しないこと
  - エンティティはユースケースのことを知らない。ユースケースより上位である
    - エンティティがアプリ非依存なのに対し、ユースケースはアプリ固有＝入出力に近いため
  - ユースケースの入力・出力は何にも依存しないシンプルなデータ構造であるべき
    - httprequestなどから派生したものではない。フレームワークやインターフェースとは関係がない
    - エンティティオブジェクトを参照してはいけない

#### 21章: 叫ぶアーキテクチャ
- ソフトウェアアプリケーションのアーキテクチャはアプリケーションのユースケースを支える
  - フレームワークに関するものではない。フレームワークは使用するツール
  - ウェブであることはアーキテクチャではない。フレームワークにアーキテクチャを乗っ取られてはいけない
- アーキテクチャがユースケースをサポートしていて、フレームワークと距離をおいていれば、フレームワークなしにユニットテスト可能
  - テストのためにウェブサーバを起動する必要も、DBに接続する必要もない

#### 22章: クリーンアーキテクチャ
- クリーンアーキテクチャの本で多分いちばん有名な図
  - 中央から、エンティティ・ユースケース・インターフェースアダプタ等・フレームワーク等、と広がる同心円。　ソースコードの依存は内側だけに向かっていなければいけない
   - エンティティ：企業全体の最重要ビジネスルール
   - ユースケース：アプリケーション固有のビジネスルール
   - インターフェイスアダプター：ユースケースやエンティティに便利なフォーマットと、DB・ウェブに便利なフォーマットを変換
   - フレームワークとドライバ：詳細が詰まっている。コードをあまり書かない
  - 境界を超えるには
   - コントローラ（第三層）→ユースケース（第二層）→プレゼンター（第三層）という処理フローの場合
   - ユースケースが呼び出すのはコントローラーでもプレゼンターでもなく、入力/出力インターフェース。コントローラやプレゼンタがそれを実装
   - 境界を超えるデータは、独立した、単純なデータ構造
     - エンティティオブジェクトやDB行をそのまま渡すのはだめ
  - 例示：DBを使ったウェブベースのJavaシステムの例
   - 処理順序とは異なる依存順序で書かれているが、実装もある程度イメージができる。だいぶ理解の助けになった

#### 23章: プレゼンターとHumble Object
- Humble Objectパターン: テストしにくい振る舞いとしやすい振る舞いを分離するパターン
  - GUIで表示・制御するものをViewModelの文字列・真偽値・列挙型で表現。PresenterでViewModelをつくり、ViewでViewModelを読んで画面移動する
  - ユースケース層はデータベースゲートウェイ（インターフェース）を用いてSQLを叩かない。このインターフェースはデータベース層のクラスで実装される。
- アーキテクチャの境界近くでこのパターンを使うとシステムのテストがしやすくなるよ

#### 24章: 部分的な境界
- 本格的な境界を作るのはコストが高い。しかし、あとで必要になるかもしれない。
  - YAGNIに違反しているが、ある程度は必要になることもあるため、部分的な境界を実装する
- 部分的な境界の作り方
  - 独立してコンパイル・デプロイ可能なコンポーネントを準備した後で、同じコンポーネントにまとめる
    - ただし、徐々に独立性が弱くなってきたりしがち
  - 片方だけの境界
    - 完全な境界はコンポーネントの双方にインターフェースを使用する
    - Strategyパターン
    - `Client -> Service Boundary Interface <|- Service Impl`
  - Facadeパターン
    - 依存関係の逆転も許容
    - `Client -> Facade(各Serviceはこのメソッドに相当) `

#### 25章: レイヤーと境界
- 簡単なコンピュータゲームを例に具体な話を
- Hunt the Wumpus (プレイヤーが簡単なテキスト入力で動くゲーム）
  - 素朴に考えると…
    - UIとルールの分離 ` (English|Spanish|..) UI~> Game Rule`
    - ゲームは状態保存のコンポーネントの詳細を知らずAPIで通信 ... `Game Rule <- (Flash|Cloud) Data `
  - 境界の軸 は複数ある。UI も言語だけでなく、通信方法（console/chat app/...)もある
    - 抽象コンポーネントを作る
    - `Text Delivery -> Language -> Game Rules <- Data Storage`
      - `Text Delivery <- SMS|Console`
      - `Language <- English|Spanish`
      - `Data Storage <- Cloud|Flash`
    - ゲームのルールを最上位にしてユーザからの通信・データの永続化の２つの情報の流れに大きく分かれる
  - 情報の流れは常に２つか？
    - マルチプレイヤーのオンラインゲームだとそうでもない
      - `Language -> Game Rules`
      - `Data Storage -> Game Rules`
      - `Network -> Game Rules`
    - さらに、ゲームルールにもマップ構造を扱う層だけでなく、プレイヤの状態を扱う上位の方針がある
      - つまり、Game Rulesは ` Move Management -> Player Management`と分割できる
- アーキテクチャの境界は色んな所に存在する。境界を設けるコスト・無視するコストの比較検討を随時行うよう、システムの変化に注意を払うべし

#### 26章: メインコンポーネント
- すべてのシステムに存在する、他のコンポーネントを作成・調整・監督するコンポーネント
- 究極的な詳細（最下位レベルの方針）。
- 以下はHunt the Wumpusの例でコードサンプルが乗ってる

#### 27章: サービス
- サービス指向アーキテクチャが流行ってる理由。…いずれも、部分的にしか正しくない
  - サービスが互いに分離されてるように見える
  - サービスが開発・デプロイを独立させてるように見える
- サービスを使用することはアーキテクチャか？：No
  - システムアーキテクチャでは、依存性のルールに従う境界を作るのが大事
  - サービスの使用＝アプリケーション振る舞いを分離するだけ。境界を作る一手段
- サービス指向アーキテクチャのメリットはなにか？
  - 異なるプロセスで動くから分離度が強い？
    - 共に扱うデータレコードには強く合意が必要なのでそこまで強い分離にならない
  - 異なるチームがサービスを所有・運用できてスケーラブル？
    - モノリシックなシステムでもスケーラブルなシステムはできる
    - 分離の仕方を間違えると、運用・デプロイを独立してできるとは限らない
- 誤りの例
  - サービス指向的にタクシー配車システムを作ったとする
    - UIサービスとFinderサービスとSelectorサービスとDispatcherサービスがある
  - もし子猫を配車するサービスを始めようとしたら…猫
    - アレルギーな人への配慮とかタクシー業者の対応する・しない変更とか全サービスに変更を考えると、全サービス変更必要
  - SOLIDの設計原則を使うと…
    - 乗車固有のロジックはFinder/Selector/Dispatcherら抽象クラスの実装となる
      - Template MethodやStrategyなどのパターン
      - これらはUIの制御下にあるFactoryから作られる
    - これならTaxiUIだけ変更すれば良い

