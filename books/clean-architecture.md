## クリーンアーキテクチャを読んでメモ
### 第一部
#### 1章

- アーキテクチャの目的はシステムの構築・保守に必要な人材を最小限に抑えること

#### 2章

- システムは「構造」と「振る舞い」からなるという。
  - 振る舞いは機能要件。構造はアーキテクチャ。前者が重視されがち
- ソフトウェアはソフトである…つまり、変更を簡単にできるべきものである。この点で構造は重要である。
- 緊急と重要は違う。振る舞いは緊急、アーキテクチャは重要。緊急かつ重要であるとは限らない。
  - 緊急と重要はどうちがう？があまり明文化されてないので若干ポエミーさを感じた。わからなくもないきはするなんとなく。

### 第二部

アーキテクチャの議論をする前の下地づくりとしての説明っぽさ

#### 3章:パラダイム

- 構造化プログラミング：gotoやめようby dijkstra。直接的な制御の移行に規律を課す
- オブジェクト指向プログラミング：クラスとかポリモーフィズムとか。間接的な制御の移行に規律を課す
- 関数型プログラミング：シンボルの値は変化しない。代入に規律を課す

どれもプログラマの行動を制限している。これらはどれもアーキクチャの３つの関心事と対応している

#### 4章: 構造化プログラミング

- パンチカードとかの時代。djkstraのモチベーションは数学の考え方を使ってプログラムを書くことっぽい
- gotoがあると分割統治とかの証明ができない->gotoいらない証明をした
- 構造化プログラミングでは、モジュールを機能的に分割できる。分割したものがテストで反証可能となれば構造化プログラミングのメリットになる。
  - テストは「正しくない」ことの証明を試みるもの。プログラムが正しい証明にはならないが。反証を試みて無理だった＝十分正しいだろう、という考え

#### 5章: オブジェクト指向プログラミング

- OOはポリモーフィズムの能力でソースコードの依存関係を絶対的に制御できる＝上位モジュール都会モジュールの分離
  - カプセル化：C言語でも実はカプセル化できる。OO言語は逆にカプセル化が弱体化してる（ヘッダファイル上でメソッド変数が見える
  - 継承: 一応C言語でもできる。でも多重継承とかはめんどい。OO言語の方が楽
  - ポリモーフィズム: Cでも関数ポインタの付け替えでできる。でも関数ポインタを使うのは危険→ポインタ経由で関数を呼び出す、という規約をなくしてポリモーフィズムしやすくしたのがOO言語
    - ポリモーフィズムがあるとIOデバイスが変わってもopen/close/read/write/seekが実装されてれば呼び出し側は変更不要。この切り分けが便利
    - HLがInterfaceを実装したMLの関数を呼ぶ、みたいな構造は `HL→Interface<|- ML`とかける。 制御の流れ(HL->ML)に対し依存・継承関係が逆転する。
       - 制御の流れと無関係に依存ができる（依存の絶対制御）＝制御される側も制御する側を切り分けられる
       - UI/ビジネスルール/DBそれぞれが独立したものにできる。独立開発・独立デプロイ可能

#### 6章: 関数型プログラミング

- 関数型言語の変数は変化しない（不変性）
- 競合・デッドロック・並行更新の問題の原因は可変変数。よって不変性は並列計算で便利
- 不変性はつかえるのか？＝妥協すれば使える
  - 不変コンポーネントにできる限り処理を押し込みつつ無理な部分は可変コンポーネント＋トランザクショナルメモリをつかって良いとする
  - 無限にリソースがあるならトランザクションを保存して必要なときにデータを作るのが完全な関数型。でもストレージが死ぬのでよしなに
    - 銀行口座の例では、金額を覚えないのが改善な関数型だが、0時には値を計算してその差分だけ計算、とか。

若干結論が見えづらく感じたが、三章にもあるように、不変性により代入に規律を課したがポイントであろう

### 第三部：設計の原則

思考の拠り所としてSOLID原則を説明する。この原則に従えば

- 変更に強い
- 理解しやすい
- コンポーネントの基盤として多くのシステムで利用できる

システムがつくれる。

#### 7章：SOLIDのS: Single Responcibility Principle(SRP)

- 単一責任の原則というが、「どのモジュールも一つのことだけやるべき」ではない。
- モジュールは、たった一つのアクター（ソフトウェアを変更したいと思う人）に対して責務を追うべき
  - Aが使う関数FをAの要求変更に合わせて変更したらBもFを使っていてトラブった、をやめたい
- データを持つクラスと処理するクラスを分ける＆処理するクラスをまとめるためにFacadeパターンがつかえる

#### 8章: SOLIDのO: Open-Closed Principle(OCP)

- ソフトウェアは拡張に対して開いていて修正に対しては閉じているべき
- 既存の成果物を変更せず拡張できるようにしたい
- 変更の理由が異なるものを分割。依存関係を依存関係逆転の原則（後にでてきそう。順序逆転や情報保護にInterfaceが使えるっぽさはある）でまとめる
 - 依存順：AがBの変更から保護されるべきなら、BからAに依存すべき。


#### 9章: SOLIDのL: リスコフの置換原則

- S型オブジェクトo1各々に対応するT型オブジェクトo2があり、Tを使って定義されたプログラムPにo2の代わりにo1を適用してもPの振る舞いが変わらないならば、SはTの派生型
  - PersonalLicenseとBusinecceLicenseはcalcFee関数を持つLicenseの派生型
  - 正方形は長方形の派生クラスではない。幅を変える・高さを変える・面積を計算するを利用するプログラムを書くとおかしなことになる
- 昔は継承の使い方指針だったが、今はインターフェースと実装の原則にまで広がってる
  - 違反の例: タクシー配車サービス。色んな会社の配車サービスが特定REST APIに対応してる前提で配車リクエストを投げる処理を書く→例外サイトが出ると大変。URIをキーにコマンド作成モジュールを作る必要がでる
  - 予めコマンド作成モジュールを作っておくべきという話ではなく、置換できない例外的モジュールはつくらないようにしようね…という主張なのかなぁ…？

#### 10章: SOLIDのI: インターフェース分離の原則(ISP)

- User1がOP1, User2がOP2, User3がOP3を使うようなクラスOPSがある。これだけだとUser1は暗黙的にOP2に依存する -> OP{1..3}を持つInterface{1..3}を使って実装させよう
- アーキテクト的にも似たようなことが言える。フレームワークFを使おうとしたら暗黙的にデータベースDに依存するようになった（つかわないのに）とかは避けたいね、という話

#### 11章: SOLIDのD: 依存関係逆転の原則(DIP)

- ソースコードの依存関係が抽象だけを参照している＝柔軟
- ガチガチに抽象化する必要はない。stringを抽象化しないでよい。
- ただ、システム内の変化しやすい具象要素には依存しないようにすべき。安定した抽象要素を使おう
  - 変化しやすい具象クラスを参照しない・継承しない・オーバーライドしない
- Abstract Factoryパターンが使える
  - ApplicationはServiceFactory(Interface)のmakeSvcでService(Interface)を作ってServiceの各操作を呼ぶ。処理内容はそれぞれの実装クラスの中でやる。

### 第四部: コンポーネントの原則

SOLIDより一段上の粒度。ソフトウェアをコンポーネントに分ける周りの話をする

#### 12章: コンポーネント

- コンポーネントとは、デプロイの単位のこと
- プログラムの置き場所の変遷
  - メモリの番地を手で書く。ライブラリもソースコードそのまま貼り付け
  - 固定の関数ライブラリとアプリケーション領域→アプリケーション肥大化で収まりきらなくなる
  - 再配置可能なバイナリとリンクローダ
  - リンクとロードの処理を切り分ける。リンカの誕生
- プログラムも肥大化よりリンクの時間も短縮効果がきいてきて、コンポーネントをプラグイン化するアーキテクチャも生まれてきた。

#### 13章: コンポーネントの凝縮性

- どのクラスをどのコンポーネントに入れる？の原則は3つある
  - 再利用・リリース等価の原則：再利用の単位とリリースの単位は等価になる
    - コンポーネントには一貫するテーマ・目的があり、それを共有するモジュールを集める
    - コンポーネントを形成するクラス・モジュールはまとめてリリース可能
    - この原則がかけると再利用性が低下する
  - 閉鎖性共通の原則：変更の理由やタイミングの同じクラスは同一コンポーネントに、異なるクラスは別コンポーネントにする
    - 単一責任の原則のコンポーネント版
    - オープン・クローズドの原則の「修正に対して閉じる」を噛み砕いたものとも言える
    - この原則がかけると変更コンポーネントが増える
  - 全再利用の原則：コンポーネントユーザに実際に使わないものの依存を強要しない
    - インターフェース分離の原則の一般化
    - 不要なものには依存しない
    - この原則がかけると不要なリリース作業が増える
- 前２つはコンポーネントを大きくするが全再利用の原則はコンポーネントを小さくする、相反する概念
  - アーキテクトは現在の状況に合わせてバランスを取るのが大事
  - フェーズによって重視するものも変わる。開発初期は再利用・リリース等価より閉鎖性共通のほうが大事

#### 14章: コンポーネントの結合

- 非循環依存関係の原則: コンポーネントは循環依存してはいけない
  - 他の人の変更が悪さをして手元でプログラムが動かなる問題に対応するための原則
    - 週次ビルド（月-木は他の人の変更を無視し、金曜は統合作業を頑張る）というてもあるが、金曜が辛くなりがちだし木・土曜にずれ込みがち
  - コンポーネントごとに分割・依存コンポーネントがリリースされたときの導入は各コンポーネントが良きタイミングで行う…という流れを機能させるには、循環依存があってはいけない。
- 循環依存を解消するには？
  - 依存関係逆転の原則を使う。`E->A`の依存がある所は、EにInterfaceを作ってAに実装させれば`A<|-E`という依存になる
  - 共通のコンポーネントCを切り出して`E->A`という依存を `E->C<-A`という依存に変える
- 依存構造は変化していくので、コンポーネント構造をトップダウンで設計は不可能
  - 状況に応じてこれまでの原則を使いつつ、コンポーネントの依存構造をシステムの論理設計に合わせて育てていくもの
- 安定依存の原則：安定度の高い方向に依存すること
  - 変動を想定したコンポーネントは変動しづらいコンポーネントから依存されてはいけない。
  - 安全度とは、簡単に手を加えることができないこと。依存もとが多いと安定。依存先が多いと不安定。
  - 依存元/(依存先＋依存元) を不安定度の指標にする
    - 依存先・依存元の数は、コンポーネントごとの依存数より内部のクラスごとの依存を見るべし（importの数）
　- コンポーネント依存を順番にたどると不安定の度合いが減少する方向だと良い
- 安定度、抽象度等価の原則：コンポーネントの抽象度は安定度と同程度であるべき
  - 上位レベルの方針は頻繁に変わってほしくないので安定コンポーネントに配置すべきだが、拡張はできるようにしておきたい→インターフェースと抽象クラスで構成すべき
  - この原則に従えば、依存をたどっていくと順に抽象度は上がる
  - 抽象度は (抽象クラスやインターフェースの数)/全クラスの数 を指標にすると良い
  - 不安定度・抽象度を２次元にマッピングしてかんがえる。(0,1)が安定かつ抽象。(1,0)が不安定かつ具象。
    - (0,0) は安定な具象コンポーネント。抽象度が低いため拡張できず、安定度が高いから変更できない。変更することがほぼないなら害はないが、変更するなら苦痛ゾーン
    - (1,1) は不安定な抽象コンポーネント。実装がないのに放置されてる抽象クラスなど。無駄。
    - (0,1)-(1,0)の線分（主系列）にコンポーネントを極力近づけたい。主系列からの距離は|不安定度+抽象度-1|で表せる
      - コンポーネントごとに主系列の距離を計算して、値の大きいものを再検討すると良い。
      - 全体の平均・分散したり、時系列の推移を分析すると良い。

### 第五部: アーキテクチャ

- アーキテクチャの目的は、開発・デプロイ・運用・保守を容易にすること。そのためには、長い期間多くの選択肢を残す戦略が重要。
  - システムを適切に動作させることは主たる目的ではない。
- 残すべき選択肢とは、重要でない詳細である。
  - ソフトウェアは「方針」と「詳細」の要素に分割できる
  - 詳細は方針の実現に必要だが、方針の振る舞いに影響を与えない。
- 優れたアーキテクトは方針と詳細を区別し、方針が詳細を把握することなく、依存することがないように両者を切り離す。また、詳細をできるだけ延期・留保できるように方針をデザインする。
- 具体的なエピソード例
  - 初期段階でDBを接続する必要はない。誰かが決めていたとしてもアーキテクトとしては「決まっていない」という
  - IOデバイスを抽象化すること利用側はデバイスを意識しないで済む
  - ディスクの詳細構造（シリンダ・ヘッダ・セクタ）を知った上でアクセスするプログラムを書くのではなく、巨大配列の要素にアクセスするようにする

#### 16章: 独立性

- アーキテクチャは、システムのユースケース・運用・開発・デプロイをサポートしなければいけない
  - ユースケースをサポート
    - システムの意図をサポートする
    - アーキテクチャレベルでシステムの意図がわかると良い。詳細は21章
  - 運用をサポート
    - アクセスレベルなど、負荷に耐えれる必要がある
    - 小さいサービスに分けるかモノリシックか。優れたアーキテクトはこれらの決定を選択肢として残しておく
  - 開発をサポート
    - コンウェイの法則：システムを設計する組織は、組織のコミュニケーション構造をコピーした構造の設計を生み出す
    - チームの行動を独立させるために、単独で開発可能なコンポーネントにシステムを分割
  - デプロイをサポート
    - 目指せ即時デプロイ
    - これもシステムの適切なコンポーネント化で実現
- これらのバランスを取るのは難しい。すべてのユースケース、運用上の成約、チーム構造、デプロイ要件がわからなかったり、変化したりする。
  - このために選択肢を残すことが重要
- レイヤーによる切り離し
  - ユースケース全部はわからずとも、基本的な意図はわかる。ここから単一責任・閉鎖性共通の原則でコンポーネントを分けられる
  - UI・アプリケーション特有ビジネスルール・一般的（ドメイン特価）ビジネスルール・データベースなど。水平レイヤの分割。
- ユースケースによる切り離し
  - 注文新規追加のほうが注文キャンセルより変更頻度が多い
  - ユースケースは、システムの水平レイヤを垂直にスライスしたもの
  - UI/ビジネスルール/DBそれぞれユースケースごとに分離してグループ化->古いユースケースに影響を出さずに追加できる
