## クリーンアーキテクチャを読んでメモ
### 第一部
#### 1章

- アーキテクチャの目的はシステムの構築・保守に必要な人材を最小限に抑えること

#### 2章

- システムは「構造」と「振る舞い」からなるという。
  - 振る舞いは機能要件。構造はアーキテクチャ。前者が重視されがち
- ソフトウェアはソフトである…つまり、変更を簡単にできるべきものである。この点で構造は重要である。
- 緊急と重要は違う。振る舞いは緊急、アーキテクチャは重要。緊急かつ重要であるとは限らない。
  - 緊急と重要はどうちがう？があまり明文化されてないので若干ポエミーさを感じた。わからなくもないきはするなんとなく。

### 第二部

アーキテクチャの議論をする前の下地づくりとしての説明っぽさ

#### 3章:パラダイム

- 構造化プログラミング：gotoやめようby dijkstra。直接的な制御の移行に規律を課す
- オブジェクト指向プログラミング：クラスとかポリモーフィズムとか。間接的な制御の移行に規律を課す
- 関数型プログラミング：シンボルの値は変化しない。代入に規律を課す

どれもプログラマの行動を制限している。これらはどれもアーキクチャの３つの関心事と対応している

#### 4章: 構造化プログラミング

- パンチカードとかの時代。djkstraのモチベーションは数学の考え方を使ってプログラムを書くことっぽい
- gotoがあると分割統治とかの証明ができない->gotoいらない証明をした
- 構造化プログラミングでは、モジュールを機能的に分割できる。分割したものがテストで反証可能となれば構造化プログラミングのメリットになる。
  - テストは「正しくない」ことの証明を試みるもの。プログラムが正しい証明にはならないが。反証を試みて無理だった＝十分正しいだろう、という考え

#### 5章: オブジェクト指向プログラミング

- OOはポリモーフィズムの能力でソースコードの依存関係を絶対的に制御できる＝上位モジュール都会モジュールの分離
  - カプセル化：C言語でも実はカプセル化できる。OO言語は逆にカプセル化が弱体化してる（ヘッダファイル上でメソッド変数が見える
  - 継承: 一応C言語でもできる。でも多重継承とかはめんどい。OO言語の方が楽
  - ポリモーフィズム: Cでも関数ポインタの付け替えでできる。でも関数ポインタを使うのは危険→ポインタ経由で関数を呼び出す、という規約をなくしてポリモーフィズムしやすくしたのがOO言語
    - ポリモーフィズムがあるとIOデバイスが変わってもopen/close/read/write/seekが実装されてれば呼び出し側は変更不要。この切り分けが便利
    - HLがInterfaceを実装したMLの関数を呼ぶ、みたいな構造は `HL→Interface<|- ML`とかける。 制御の流れ(HL->ML)に対し依存・継承関係が逆転する。
       - 制御の流れと無関係に依存ができる（依存の絶対制御）＝制御される側も制御する側を切り分けられる
       - UI/ビジネスルール/DBそれぞれが独立したものにできる。独立開発・独立デプロイ可能

#### 6章: 関数型プログラミング

- 関数型言語の変数は変化しない（不変性）
- 競合・デッドロック・並行更新の問題の原因は可変変数。よって不変性は並列計算で便利
- 不変性はつかえるのか？＝妥協すれば使える
  - 不変コンポーネントにできる限り処理を押し込みつつ無理な部分は可変コンポーネント＋トランザクショナルメモリをつかって良いとする
  - 無限にリソースがあるならトランザクションを保存して必要なときにデータを作るのが完全な関数型。でもストレージが死ぬのでよしなに
    - 銀行口座の例では、金額を覚えないのが改善な関数型だが、0時には値を計算してその差分だけ計算、とか。

若干結論が見えづらく感じたが、三章にもあるように、不変性により代入に規律を課したがポイントであろう

### 第三部：設計の原則

思考の拠り所としてSOLID原則を説明する。この原則に従えば

- 変更に強い
- 理解しやすい
- コンポーネントの基盤として多くのシステムで利用できる

システムがつくれる。

#### 7章：SOLIDのS: Single Responcibility Principle(SRP)

- 単一責任の原則というが、「どのモジュールも一つのことだけやるべき」ではない。
- モジュールは、たった一つのアクター（ソフトウェアを変更したいと思う人）に対して責務を追うべき
  - Aが使う関数FをAの要求変更に合わせて変更したらBもFを使っていてトラブった、をやめたい
- データを持つクラスと処理するクラスを分ける＆処理するクラスをまとめるためにFacadeパターンがつかえる

#### 8章: SOLIDのO: Open-Closed Principle(OCP)

- ソフトウェアは拡張に対して開いていて修正に対しては閉じているべき
- 既存の成果物を変更せず拡張できるようにしたい
- 変更の理由が異なるものを分割。依存関係を依存関係逆転の原則（後にでてきそう。順序逆転や情報保護にInterfaceが使えるっぽさはある）でまとめる
 - 依存順：AがBの変更から保護されるべきなら、BからAに依存すべき。


#### 9章: SOLIDのL: リスコフの置換原則

- S型オブジェクトo1各々に対応するT型オブジェクトo2があり、Tを使って定義されたプログラムPにo2の代わりにo1を適用してもPの振る舞いが変わらないならば、SはTの派生型
  - PersonalLicenseとBusinecceLicenseはcalcFee関数を持つLicenseの派生型
  - 正方形は長方形の派生クラスではない。幅を変える・高さを変える・面積を計算するを利用するプログラムを書くとおかしなことになる
- 昔は継承の使い方指針だったが、今はインターフェースと実装の原則にまで広がってる
  - 違反の例: タクシー配車サービス。色んな会社の配車サービスが特定REST APIに対応してる前提で配車リクエストを投げる処理を書く→例外サイトが出ると大変。URIをキーにコマンド作成モジュールを作る必要がでる
  - 予めコマンド作成モジュールを作っておくべきという話ではなく、置換できない例外的モジュールはつくらないようにしようね…という主張なのかなぁ…？

#### 10章: SOLIDのI: インターフェース分離の原則(ISP)

- User1がOP1, User2がOP2, User3がOP3を使うようなクラスOPSがある。これだけだとUser1は暗黙的にOP2に依存する -> OP{1..3}を持つInterface{1..3}を使って実装させよう
- アーキテクト的にも似たようなことが言える。フレームワークFを使おうとしたら暗黙的にデータベースDに依存するようになった（つかわないのに）とかは避けたいね、という話

#### 11章: SOLIDのD: 依存関係逆転の原則(DIP)

- ソースコードの依存関係が抽象だけを参照している＝柔軟
- ガチガチに抽象化する必要はない。stringを抽象化しないでよい。
- ただ、システム内の変化しやすい具象要素には依存しないようにすべき。安定した抽象要素を使おう
  - 変化しやすい具象クラスを参照しない・継承しない・オーバーライドしない
- Abstract Factoryパターンが使える
  - ApplicationはServiceFactory(Interface)のmakeSvcでService(Interface)を作ってServiceの各操作を呼ぶ。処理内容はそれぞれの実装クラスの中でやる。

### 第四部：コンポーネントの原則

SOLIDより一段上の粒度。ソフトウェアをコンポーネントに分ける周りの話をする

#### 12章：コンポーネント

- コンポーネントとは、デプロイの単位のこと
